#!/usr/bin/env python3

import sys
import os
import requests
import json
import subprocess

from threading import Timer
#todo:
#set timer for search so search only happens when stop typing done
#look through rofiftw to see how rofi blocks is used done
#look through rofi blocks examples done
#set up oauth custom url and queries in this python script (search, mutation)
#(done in lua) loop through anilist entries in json and determine which series is currently being updated based on episode number
class Anilist:
    def __init__(self):
        self.url = 'https://graphql.anilist.co'
        self.curr_search = {}
        return
    def search(self, input):
        if not input or len(input) == 1: return []
        query = '''
            query($search: String) {
                Page(page: 1, perPage: 7)  {
                    media(search: $search, type: ANIME) {
                        id
                        title {
                            romaji
                        }
                    } 
                }
            }
        '''
        variables = {
            'search': input
        }
        response = requests.post(self.url, json={'query': query, 'variables': variables})
        titles = self._get_titles(response.json())
        return titles

    def _get_titles(self, response):
        self.curr_search = {}
        media = response['data']['Page']['media']
        titles = []
        for entry in media:
            title = entry['title']['romaji']
            #for sending to rofiblocks
            titles.append(title)
            self.curr_search[title] = entry['id']
        return titles

    def mutate(self):
        return
class TimerWrapper():
    def __init__(self):
        self.timer = None

    #if timer hasn't called cb yet, filter current results instead of doing nothing
    def start_timer(self, cb):
        if self.timer:
            self.timer.cancel()
        self.timer = Timer(0.5, cb)
        self.timer.start()



#rofi blocks doesn't read python's stdout; need to use bash
def print_bash(msg):
    subprocess.run([f'echo \'{msg}\''], shell=True)

def format_lines(input):
    message = {}
    message['lines'] = [{'text': entry} for entry in input]
    return json.dumps(message)

def send_lines(lines):
    msg = format_lines(lines)
    print_bash(msg)



api = Anilist()
timer = TimerWrapper()

import webbrowser

print_bash('{"input action":"send", "prompt":"ï„ "}')
def main(line):
    line_json = json.loads(line)
    name = line_json['name']
    value = line_json['value']
    if name == 'input change': 
        query = json.loads(line)['value']
        cb = lambda: send_lines(api.search(query))
        timer.start_timer(cb)
    elif name == 'select entry':
        #somehow communicate between lua script
        #webbrowser.open(f'https://anilist.co/anime/{api.curr_search[value]}')
        sys.stdout.write(str(api.curr_search[value]))
        print(api.curr_search[value], file=sys.stderr)
        sys.exit(0)

    print(json.loads(line), file=sys.stderr)

try:
    for line in sys.stdin:
        print(line)
        main(line)
except Exception as e:
    print (e, file = sys.stderr)
